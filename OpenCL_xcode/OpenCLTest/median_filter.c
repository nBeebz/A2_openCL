/**
 * File generated by OpenCL CodeBench on Thu May 30 20:00:24 2013
 *
 * THIS CODE IS MADE AVAILABLE “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY 
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
 * AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef __MEDIAN_FILTER_H_
#include "median_filter.h"
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/time.h>

void checkResult_  (int, const char*, int);
void checkEvent_   (cl_event, const char*, int);
#define checkResult(v) checkResult_(v, __FILE__, __LINE__)
#define checkEvent(v) checkEvent_(v, __FILE__, __LINE__)

#define ITERS (100)

/********************************************************************************
 * Static OpenCL variables
 *******************************************************************************/

static median_filter _instance;
static int isInitialized = 0;  // init has been called
static int isSetup = 0; // setup has been called

/********************************************************************************
 * Generated Interface Functions
 *******************************************************************************/

/**
 * Initialize the OpenCL driver and 
 * obtain a command queue.
 */
void median_filter_init(median_filter* self) {
  cl_int ret;

  // Get a platform - pick the first one found
  cl_platform_id platform;
  
  ret = clGetPlatformIDs(1, &platform, NULL);
  checkResult(ret);
  
  // Get all the CPU and GPU devices
  ret = clGetDeviceIDs(
    platform, CL_DEVICE_TYPE_GPU|CL_DEVICE_TYPE_CPU, 
    MAX_NUM_DEV, &self->device[0], &self->noOfDevices);		   
  checkResult(ret);

  // reverse the list of allocated devices for better performance
  for (int i=0; i<self->noOfDevices/2; ++i) {
    cl_device_id tmp = self->device[i];
    self->device[i] = self->device[self->noOfDevices-i-1];
    self->device[self->noOfDevices-i-1] = tmp;
  }

  // Create a context and command queue on that device
  self->context = clCreateContext(
    NULL, self->noOfDevices, &self->device[0], NULL, NULL, &ret);
  checkResult(ret);

  // print the device types found
  for (int i=0; i<self->noOfDevices; ++i) {
    cl_device_type t;
    self->queue[i] = clCreateCommandQueue(
      self->context, self->device[i], 0, &ret);
    checkResult(ret);
    ret = clGetDeviceInfo(self->device[i], CL_DEVICE_TYPE, sizeof(t), &t, NULL);
    checkResult(ret);
    if (t & CL_DEVICE_TYPE_CPU)
      printf(" INFO: device[%d].type = CL_DEVICE_TYPE_CPU\n", i);
    if (t & CL_DEVICE_TYPE_GPU)
      printf(" INFO: device[%d].type = CL_DEVICE_TYPE_GPU\n", i);
    if (t & CL_DEVICE_TYPE_ACCELERATOR)
      printf(" INFO: device[%d].type = CL_DEVICE_TYPE_ACCELERATOR\n", i);
    if (t & CL_DEVICE_TYPE_DEFAULT)
      printf(" INFO: device[%d].type = CL_DEVICE_TYPE_DEFAULT\n", i);
  }


  // check the current load distribution
  int sum = 0;
  for (int i=0; i<self->noOfDevices; i++) {
    sum += self->load[i];
  }

  // if we don't have a pre-initialized valid load
  // assume equal load balancing
  // Assume F is divisible by number of devices
  if (sum == 0) {
    for (int i=0; i<self->noOfDevices; i++) {
      self->load[i] = F/self->noOfDevices;
    }
  }
}

/**
 * Open a file for reading.
 *
 * @filename Base file name
 * @info If not NULL, used to store the information retrieved with stat
 * @return Valid FILE handle if successful
 */
FILE* open_file(const char *filename, struct stat *info) {
  FILE* in = NULL;

  // gather file info if info parameter provided
  if (info) {
    if (stat(filename, info)) {
      fprintf(stderr,"ERROR: Could not stat : %s\n", filename);
      exit(-1);
    }
  }

  // Open the file
  if ((in=fopen(filename, "rb"))==NULL) {
    fprintf(stderr, "ERROR: Could not open file: '%s'\n", filename);
    exit(EXIT_FAILURE);
  }

  return in;
}

/**
 * Read an OpenCL kernel source file into a character buffer.
 *
 * @kernelFilename Full path name of the kernel file
 * @return Character array sized to fit the kernel file text, allocated on the heap.
 */
const char * median_filter_read_source(const char *kernelFilename)
{
  struct stat buf;
  FILE* in = open_file(kernelFilename, &buf);

  size_t size = buf.st_size;
  char *src = (char*)malloc(size+1);

  // Read the file content
  int len=0;
  if ((len = fread((void *)src, 1, size, in)) != (int)size) {
    fprintf(stderr, "ERROR: Read was not completed : %d / %lu bytes\n", len, size);
    exit(EXIT_FAILURE);
  }
  
  // end-of-string
  src[len]='\0';
  fclose(in);
  return src;
}

/**
 * Create the kernel and buffers
 *
 * @source String containing kernel source code.
 */
void median_filter_setup(median_filter* self, const char *source, cl_int width, cl_int heigth) {
   int ret;
   if (source == 0) {
     fprintf(stderr, "ERROR - in %s:%d: kernel source string for median_filter is NULL\n", __FILE__, __LINE__);
   }

   // Perform runtime source compilation, and obtain kernel entry point.
   self->program = clCreateProgramWithSource(
     self->context,
     1,
     &source,
     NULL, &ret );
   checkResult(ret);

   ret = clBuildProgram(
     self->program, self->noOfDevices, &self->device[0], NULL, NULL, NULL );
   checkResult(ret);
   
   self->kernel = clCreateKernel(self->program, "krnl_median_filter", &ret);
   checkResult(ret);

   // Create data buffers
   self->buffer_x = clCreateBuffer(
     self->context, CL_MEM_READ_ONLY,  width*heigth * sizeof(cl_uint), NULL, &ret);
   checkResult(ret);
   self->buffer_y = clCreateBuffer(
     self->context, CL_MEM_WRITE_ONLY, width*heigth * sizeof(cl_uint), NULL, &ret);
   checkResult(ret);

  // Set the kernel arguments
   clSetKernelArg(self->kernel, 0, sizeof(self->buffer_x), (void*) &self->buffer_x);
   clSetKernelArg(self->kernel, 1, sizeof(self->buffer_y), (void*) &self->buffer_y);
}

static median_filter* getInstance() {
  if (!isInitialized) {
    median_filter_init(&_instance);
    isInitialized = 1;
  }
  return &_instance;
}

void median_filter_setLoadFactors(int *factors) {
  median_filter* instancePtr = getInstance();
  int sum = 0;
  // verify that the sum of all factors equals F (1)
  for (int i=0; i<instancePtr->noOfDevices; i++)
    sum += factors[i];
  if (sum == F) {
    for (int i=0; i<instancePtr->noOfDevices; ++i) 
      instancePtr->load[i] = factors[i];
  }
  else {
    printf(" ERROR: sum of load factors is not equal to %d (sum=%d)\n", F, sum);
  }
}

/**
 * Compute the next sequence of load factors based on the current ones.
 * Starting from {F, 0, 0, ..., 0}, repeatedly calling this function
 * will cycle through all the possible load factor sequences.
 */
static int incLoadFactors(int* factors, int length) {
  int rpos = 0, lpos=0; 

  if (factors[length-1] == F) return 0;
  
  // find rightmost non-zero factor
  for (int i=length-1; i>=0; i--) {	
    if (factors[i]) {
      rpos = i;
      break;
    }
  }

  // was last factor
  if (rpos == length-1) {
    // find first nonzero factor to the left
    for (int i=rpos-1; i>=0; i--) {
      if (factors[i]) {
	lpos = i;
	break;
      }
    }
    factors[lpos] --;
    factors[lpos+1] = factors[rpos] + 1;
    if (rpos > lpos+1) 
      factors[rpos] = 0;
  }
  else {
    factors[rpos] --;
    factors[rpos+1] ++;
  }
  return 1;
}

int median_filter_getNoOfDevices() {
    return (int) getInstance()->noOfDevices;
}

/**
 * Run the kernel
 */
void median_filter_run(cl_uint *x, cl_uint *y, cl_int width, cl_int heigth)
{
    median_filter* instancePtr = getInstance();
    int numWrEv =0;
    cl_event wrEv[1];
    int numRdEv = 0;
    cl_event rdEv[MAX_NUM_DEV];
    cl_event enqEv[MAX_NUM_DEV];

    if (!isSetup) {
        const char* src = 0;
        src = median_filter_read_source("./median_filter.cl");
        median_filter_setup(instancePtr, src, width, heigth);
        free((char*)src);
        isSetup = 1;
    }

    // Launch the kernel. Let OpenCL pick the local work size
    cl_int ret;
    size_t global_work_size[] = {width,heigth,};
    size_t global_work_offset[] = {0,0,};
    size_t totalOffset = 0;
    size_t totalWork = global_work_size[0];

    ret = clSetKernelArg(instancePtr->kernel, 2, sizeof(width), (void*) &width);
    checkResult(ret);

    ret = clSetKernelArg(instancePtr->kernel, 3, sizeof(heigth), (void*) &heigth);
    checkResult(ret);

    // copy input data
    ret = clEnqueueWriteBuffer(
      instancePtr->queue[0], instancePtr->buffer_x, CL_FALSE, 0,
      sizeof(cl_uint)*width*heigth, x, 0, NULL, &wrEv[numWrEv++]);
    checkResult(ret);

    // launch the kernel
    for (int i=0; i<instancePtr->noOfDevices; ++i) {
      // adapt first dimension to reflect partial work load
      size_t workSize = (instancePtr->load[i] * totalWork)/F;
      if (workSize) {
        global_work_size[0] = workSize;
        global_work_offset[0] = totalOffset;
        ret = clEnqueueNDRangeKernel(instancePtr->queue[i],
                                     instancePtr->kernel,
                                     sizeof(global_work_size)/sizeof(size_t),
                                     global_work_offset,
                                     global_work_size,
                                     NULL, // let OpenCL determine localWorkSize
                                     numWrEv, wrEv, 
                                     &enqEv[i]);
        checkResult(ret);
        ret = clEnqueueReadBuffer(instancePtr->queue[i], 
                                  instancePtr->buffer_y, CL_FALSE, 
                                  global_work_offset[0]*heigth*sizeof(cl_uint), 
				  global_work_size[0]*heigth*sizeof(cl_uint), 
                                  ((char*)y)+global_work_offset[0]*heigth*sizeof(cl_uint), 
                                  1, &enqEv[i], &rdEv[numRdEv++]);
        checkResult(ret);
      }
      totalOffset += workSize;
   }


    // wait for all the results to be read
    ret = clWaitForEvents(numRdEv, rdEv);
}

/**
 * release all allocated resources
 */
void median_filter_tearDown() {
  median_filter* instancePtr = getInstance();
  clReleaseMemObject(instancePtr->buffer_x);
  clReleaseMemObject(instancePtr->buffer_y);
  clReleaseProgram(instancePtr->program);
  clReleaseCommandQueue(instancePtr->queue[0]);
  clReleaseCommandQueue(instancePtr->queue[1]);
  clReleaseContext(instancePtr->context);
  isSetup = isInitialized = 0;
}

/*********************************************************************************
 * Utility Functions
 ********************************************************************************/

/**
 * Retrieve error message for a given error code
 *
 * @error Error code to be converted to a string.
 */
const char * median_filter_result_to_string(int error) {
  median_filter* instancePtr = getInstance();
  switch (error) {
    case CL_SUCCESS:
      return (const char*)"Success";
    case CL_DEVICE_NOT_FOUND:
      return (const char*)"Device Not Found";
    case CL_DEVICE_NOT_AVAILABLE:
      return (const char*)"Device Not Available";
    case CL_COMPILER_NOT_AVAILABLE:
      return (const char*)"Compiler Not Available";
    case CL_MEM_OBJECT_ALLOCATION_FAILURE:
      return (const char*)"Mem Object Allocation Failure";
    case CL_OUT_OF_RESOURCES:
      return (const char*)"Out Of Resources";
    case CL_OUT_OF_HOST_MEMORY:
      return (const char*)"Out Of Host Memory";
    case CL_PROFILING_INFO_NOT_AVAILABLE:
      return (const char*)"Profiling Info Not Available";
    case CL_MEM_COPY_OVERLAP:
      return (const char*)"Mem Copy Overlap";
    case CL_IMAGE_FORMAT_MISMATCH:
      return (const char*)"Image Format Mismatch";
    case CL_IMAGE_FORMAT_NOT_SUPPORTED:
      return (const char*)"Image Format Not Supported";
    case CL_BUILD_PROGRAM_FAILURE:
      {
	#define CL_BUILD_PROGRAM_FAILURE_MSG "Build Program Failure : "
        #define AMDL_DEBUG_BUFFER_SIZE 2048
	static char debug_buffer[AMDL_DEBUG_BUFFER_SIZE];
	strncat(debug_buffer,CL_BUILD_PROGRAM_FAILURE_MSG,AMDL_DEBUG_BUFFER_SIZE);
	clGetProgramBuildInfo(instancePtr->program,
			      instancePtr->device[0],
			      CL_PROGRAM_BUILD_LOG ,
			      AMDL_DEBUG_BUFFER_SIZE,
			      debug_buffer+strlen(CL_BUILD_PROGRAM_FAILURE_MSG),
			      NULL);
        return (const char*)debug_buffer;
      }
    case CL_MAP_FAILURE:
      return (const char*)"Map Failure";
    case CL_INVALID_VALUE:
      return (const char*)"Invalid Value";
    case CL_INVALID_DEVICE_TYPE:
      return (const char*)"Invalid Device Type";
    case CL_INVALID_PLATFORM:
      return (const char*)"Invalid Platform";
    case CL_INVALID_DEVICE:
      return (const char*)"Invalid Device";
    case CL_INVALID_CONTEXT:
      return (const char*)"Invalid Context";
    case CL_INVALID_QUEUE_PROPERTIES:
      return (const char*)"Invalid Queue Properties";
    case CL_INVALID_COMMAND_QUEUE:
      return (const char*)"Invalid Command Queue";
    case CL_INVALID_HOST_PTR:
      return (const char*)"Invalid Host Ptr";
    case CL_INVALID_MEM_OBJECT:
      return (const char*)"Invalid Mem Object";
    case CL_INVALID_IMAGE_FORMAT_DESCRIPTOR:
      return (const char*)"Invalid Image Format Descriptor";
    case CL_INVALID_IMAGE_SIZE:
      return (const char*)"Invalid Image Size";
    case CL_INVALID_SAMPLER:
      return (const char*)"Invalid Sampler";
    case CL_INVALID_BINARY:
      return (const char*)"Invalid Binary";
    case CL_INVALID_BUILD_OPTIONS:
      return (const char*)"Invalid Build Options";
    case CL_INVALID_PROGRAM:
      return (const char*)"Invalid Program";
    case CL_INVALID_PROGRAM_EXECUTABLE:
      return (const char*)"Invalid Program Executable";
    case CL_INVALID_KERNEL_NAME:
      return (const char*)"Invalid Kernel Name";
    case CL_INVALID_KERNEL_DEFINITION:
      return (const char*)"Invalid Kernel Definition";
    case CL_INVALID_KERNEL:
      return (const char*)"Invalid Kernel";
    case CL_INVALID_ARG_INDEX:
      return (const char*)"Invalid Arg Index";
    case CL_INVALID_ARG_VALUE:
      return (const char*)"Invalid Arg Value";
    case CL_INVALID_ARG_SIZE:
      return (const char*)"Invalid Arg Size";
    case CL_INVALID_KERNEL_ARGS:
      return (const char*)"Invalid Kernel Args";
    case CL_INVALID_WORK_DIMENSION:
      return (const char*)"Invalid Work Dimension";
    case CL_INVALID_WORK_GROUP_SIZE:
      return (const char*)"Invalid Work Group Size";
    case CL_INVALID_WORK_ITEM_SIZE:
      return (const char*)"Invalid Work Item Size";
    case CL_INVALID_GLOBAL_OFFSET:
      return (const char*)"Invalid Global Offset";
    case CL_INVALID_EVENT_WAIT_LIST:
      return (const char*)"Invalid Event Wait List";
    case CL_INVALID_EVENT:
      return (const char*)"Invalid Event";
    case CL_INVALID_OPERATION:
      return (const char*)"Invalid Operation";
    case CL_INVALID_GL_OBJECT:
      return (const char*)"Invalid GL Object";
    case CL_INVALID_BUFFER_SIZE:
      return (const char*)"Invalid Buffer Size";
    case CL_INVALID_MIP_LEVEL:
      return (const char*)"Invalid Mip Level";
    case CL_INVALID_GLOBAL_WORK_SIZE:
      return (const char*)"Invalid Global Work Size";
    case CL_INVALID_PROPERTY:
      return (const char*)"Invalid Property";
    default:
      break;
    }
  return "Unknown";
} 

/**
 * Check Error Code.
 *
 * @errorCode Error code to be checked.
 * @file File from which this function is called.
 * @line Line in the file, from which this is called.
 */
void checkResult_(int errorCode, const char* file, int line) {	
  if (errorCode != CL_SUCCESS) { // or CL_COMPLETE - also 0
    fprintf(stderr, "ERROR - in %s:%d: %s\n", file, line, 
            median_filter_result_to_string(errorCode));
    exit(-1);
  }  
}

/**
 * Check the status of the execution of a command.
 *
 * @ev OpenCL event object to be examined.
 * @file File from which this function was called.
 * @line Line in the file from which this was called.
 */
void checkEvent_(cl_event ev, const char* file, int line) {
  int result=0;
  size_t bytes_copied=0;
  clGetEventInfo(ev, CL_EVENT_COMMAND_EXECUTION_STATUS,
		 sizeof(result), &result, &bytes_copied);
  checkResult_(result, file, line);
  clRetainEvent(ev);
}

/********************************************************************************
 * Testcase init values
 ********************************************************************************/

cl_int basics_width_init[] = {512};

cl_int basics_heigth_init[] = {512};
/**
 * Read the next 'cl_uint' value from a file.
 *
 * @f The (open) file to read from.
 * @val A pointer to the return value.
 * @return 0 if succesful.
 */
int get_next_cl_uint_value(FILE* f, cl_uint* val) {
  // read past any white-space character or comma
  int c, i=0;
  char buf[128]; // this will be the max length of our number we can read
  while ((c= getc(f)) != EOF) {
    // skip ws and commas
    if (!(c == '\n' || c == '\r' || c == ' ' || c == '\t' || c == ',')) {
      buf[i++] = (char)c;
    }
    // stop if we have read anything else (assume a number)
    else if (i!=0) break;
  }
  // flag not enough values in file.
  if (i==0) {
    return -1;
  }
  // terminate string
  buf[i] = 0;
  *  val = (cl_uint)strtod(buf, NULL);
  return 0;
}

/**
 * Copy cl_uint initialization data.
 *
 * @out The variable to copy the data to.
 * @len Length of the input and output arrays.
 * @init Array containing the source init data.
 */
void median_filter_finit_cl_uint(cl_uint *out, int len, const char  *filename) {
  int i;
  FILE *fin = open_file(filename, NULL);
  int ret = 0;
  for (i=0; i<len; ++i) {
    ret = get_next_cl_uint_value(fin, &out[i]);
  }
}
/**
 * Copy cl_int initialization data.
 *
 * @out The variable to copy the data to.
 * @len Length of the input and output arrays.
 * @init Array containing the source init data.
 */
void median_filter_init_cl_int(cl_int *out, int len, cl_int *init) {
  int i;
  for (i=0; i<len; ++i) {
    out[i] = init[i];
  }
}


/********************************************************************************
 * Test Suite                                                        
 ********************************************************************************/

/**
 * Run the 'basics' test case and check the result.
 *
 * @return number of failed tests.
 */
int median_filter_basics_run() {
  int noOfErrors = 0;
  cl_int width;
  cl_int heigth;
  median_filter_init_cl_int(&width, 1, basics_width_init);
  median_filter_init_cl_int(&heigth, 1, basics_heigth_init);


  // Initial load: all compute on first device
  const int noOfDevices = median_filter_getNoOfDevices();
  int loadFactors[noOfDevices];
  memset(loadFactors, 0, sizeof(int)*noOfDevices);
  loadFactors[0] = F;

  do {

    median_filter_setLoadFactors(loadFactors);

    // print current load factors set.
    printf(" INFO: Load factors = ");
    for (int i=0; i<noOfDevices; ++i) {
      printf("%d ", loadFactors[i]);
    }
    printf("\n");

    // initialize the test data
    cl_uint x[width][heigth];
    cl_uint y[width][heigth];

    median_filter_finit_cl_uint((cl_uint*)x, width*heigth, "x.csv");

    // start timing
    struct timeval start, end;
    gettimeofday(&start, NULL);

    // run the test ITERS times
    for (int iter = 0; iter<ITERS; ++iter)
      median_filter_run((cl_uint*)x, (cl_uint*)y, width, heigth);

    // end timing
    gettimeofday(&end, NULL);
    printf(" INFO: Wall time for basics (%d iterations) = %f s\n", 100,
           (double) (end.tv_usec - start.tv_usec)/1000000 + (double) (end.tv_sec - start.tv_sec));

    // check results against reference output
    FILE* fexpect = open_file("y.csv", NULL);
    cl_uint expectedValue;
    for (int d0=0; d0<width; ++d0) {
      for (int d1=0; d1<heigth; ++d1) {
        get_next_cl_uint_value(fexpect, &expectedValue);
        if(y[d0][d1] != expectedValue) noOfErrors++;
      }
    }

  } while (incLoadFactors(loadFactors, noOfDevices));

  printf(" INFO: basics: %d error(s) -> %s\n", noOfErrors, noOfErrors? "FAILED" : "OK");
  median_filter_tearDown();
  return noOfErrors;						     
}

/**
 * Run the test suite for the 'median_filter' OpenCL Accelerator.
 */
void median_filter_run_testsuite() {
  // Run all the test cases
  median_filter_basics_run();
}

/*********************************************************************************
 * Main function
 ********************************************************************************/

int main() {
  median_filter_run_testsuite();
  return 0;
}
